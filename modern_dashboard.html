<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IoT ÌôòÍ≤Ω Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Roboto", "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: #f8f9fa;
        min-height: 100vh;
        color: #212121;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
        padding-top: 100px;
      }

      .header {
        background: white;
        padding: 16px 20px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        width: 100%;
        box-sizing: border-box;
      }

      .logo {
        height: 40px;
        width: auto;
        object-fit: contain;
      }

      .header-content {
        text-align: center;
        flex: 1;
      }

      .header-content h1 {
        font-size: 2rem;
        font-weight: 700;
        color: #000000;
        margin: 0;
        line-height: 1.2;
      }

      .header-content p {
        font-size: 0.875rem;
        color: #666;
        font-weight: 400;
        margin: 0;
        margin-top: 2px;
      }

      .header-spacer {
        width: 40px;
      }

      .controls {
        background: white;
        padding: 25px;
        border-radius: 8px;
        margin-bottom: 30px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
        flex-wrap: wrap;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        min-width: 150px;
      }

      .control-group.horizontal {
        flex-direction: row;
        gap: 15px;
        min-width: auto;
      }

      .control-group.left {
        flex-direction: row;
        gap: 20px;
        align-items: center;
        min-width: auto;
        flex: 1;
      }

      .control-group label {
        font-weight: 600;
        color: #555;
        font-size: 0.9rem;
      }

      .slider {
        width: 150px;
        height: 4px;
        border-radius: 2px;
        background: #e0e0e0;
        outline: none;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #1976d2;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #1976d2;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .btn {
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        min-width: 120px;
      }

      .btn.giant {
        padding: 20px 40px;
        font-size: 1.2rem;
        font-weight: 600;
        min-width: 200px;
        border-radius: 8px;
      }

      .btn-primary {
        background: #1976d2;
        color: white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .btn-primary:hover {
        background: #1565c0;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      .btn-primary:active {
        background: #0d47a1;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      }

      .status {
        padding: 6px 12px;
        border-radius: 4px;
        font-weight: 500;
        font-size: 0.8rem;
        display: flex;
        align-items: center;
        gap: 6px;
        min-width: 100px;
        justify-content: center;
      }

      .status.giant {
        padding: 20px 40px;
        border-radius: 8px;
        font-size: 1.2rem;
        font-weight: 600;
        min-width: 200px;
        gap: 10px;
      }

      .status.small {
        padding: 8px 16px;
        border-radius: 4px;
        font-size: 0.9rem;
        font-weight: 500;
        min-width: 120px;
        gap: 6px;
      }

      .status.active {
        background: #e8f5e8;
        color: #2e7d32;
        border: 1px solid #4caf50;
      }

      .status.paused {
        background: #fff3e0;
        color: #f57c00;
        border: 1px solid #ff9800;
      }

      .status-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
      }

      .status.giant .status-indicator {
        width: 12px;
        height: 12px;
      }

      .status-indicator.active {
        background: #4caf50;
      }

      .status-indicator.paused {
        background: #ff9800;
      }

      .metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 30px;
        margin-bottom: 30px;
        justify-items: center;
      }

      .metric-card {
        background: white;
        padding: 25px;
        border-radius: 50%;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        text-align: center;
        transition: box-shadow 0.2s ease;
        width: 200px;
        height: 200px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        margin: 0 auto;
      }

      .metric-card:hover {
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
      }

      .metric-icon {
        font-size: 2rem;
        margin-bottom: 8px;
      }

      .metric-label {
        font-size: 1.2rem;
        color: #666;
        margin-bottom: 8px;
        font-weight: 500;
      }

      .metric-value {
        font-size: 1.8rem;
        font-weight: 700;
        color: #333;
        line-height: 1;
      }

      .metric-unit {
        font-size: 0.8rem;
        color: #888;
        margin-left: 3px;
      }

      .metric-status {
        font-size: 0.9rem;
        font-weight: 600;
        margin-top: 8px;
        padding: 4px 8px;
        border-radius: 12px;
        text-align: center;
      }

      .metric-status.normal {
        background: #e8f5e8;
        color: #2e7d32;
        border: 1px solid #4caf50;
      }

      .metric-status.danger {
        background: #ffebee;
        color: #c62828;
        border: 1px solid #f44336;
      }

      .charts-container {
        background: white;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .charts-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 30px;
      }

      .chart-container {
        position: relative;
        height: 300px;
        background: #fafafa;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
      }

      .chart-title {
        font-size: 1.1rem;
        font-weight: 600;
        color: #333;
        margin-bottom: 15px;
        text-align: center;
      }

      @media (max-width: 768px) {
        .container {
          padding: 10px;
        }

        .header h1 {
          font-size: 2rem;
        }

        .controls {
          flex-direction: column;
          gap: 20px;
        }

        .metrics {
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        }

        .charts-grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- ÏÉÅÎã® Í≥†Ï†ïÎ∞î -->
      <div class="header">
        <img src="logo.png" alt="Gongdo Logo" class="logo" />
        <div class="header-content">
          <h1>IoT Î™®ÎãàÌÑ∞ÎßÅ ÎåÄÏãúÎ≥¥Îìú</h1>
        </div>
        <div class="header-spacer"></div>
      </div>

      <!-- Controls -->
      <div class="controls">
        <div class="control-group">
          <label for="interval">Îç∞Ïù¥ÌÑ∞ Í∞±Ïã† Ï£ºÍ∏∞ (Ï¥à)</label>
          <input
            type="range"
            id="interval"
            class="slider"
            min="0.5"
            max="5"
            step="0.5"
            value="1"
          />
          <span id="intervalValue">1.0Ï¥à</span>
        </div>
        <div id="status" class="status paused small">
          <div class="status-indicator paused"></div>
          ÏÉÅÌÉú: ÎåÄÍ∏∞ Ï§ë
        </div>
        <div id="picoStatus" class="status paused small">
          <div class="status-indicator paused"></div>
          ÌîºÏΩî: Ïó∞Í≤∞ ÏïàÎê®
        </div>
        <div
          style="
            flex: 0.5;
            display: flex;
            align-items: center;
            justify-content: center;
          "
        >
          <span
            style="
              color: #666;
              font-size: 1.2rem;
              font-weight: 500;
              text-align: center;
            "
          >
            Ïö∞Ï∏° Î≤ÑÌäºÏùÑ ÎàåÎ•¥ÏÑ∏Ïöî üëâ
          </span>
        </div>
        <button id="startBtn" class="btn btn-primary giant">
          Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
        </button>
      </div>

      <!-- Metrics -->
      <div class="metrics">
        <div class="metric-card">
          <div class="metric-icon">üå°Ô∏è</div>
          <div class="metric-label">Ïò®ÎèÑ</div>
          <div class="metric-value">
            <span id="tempValue">25.0</span>
            <span class="metric-unit">¬∞C</span>
          </div>
          <div class="metric-status normal" id="tempStatus">Ï†ïÏÉÅ</div>
        </div>
        <div class="metric-card">
          <div class="metric-icon">üíß</div>
          <div class="metric-label">ÏäµÎèÑ</div>
          <div class="metric-value">
            <span id="humidityValue">60.0</span>
            <span class="metric-unit">%</span>
          </div>
          <div class="metric-status normal" id="humidityStatus">Ï†ïÏÉÅ</div>
        </div>
        <div class="metric-card">
          <div class="metric-icon">üîä</div>
          <div class="metric-label">ÏÜåÎ¶¨</div>
          <div class="metric-value">
            <span id="soundValue">50.0</span>
            <span class="metric-unit">dB</span>
          </div>
          <div class="metric-status normal" id="soundStatus">Ï†ïÏÉÅ</div>
        </div>
        <div class="metric-card">
          <div class="metric-icon">üåä</div>
          <div class="metric-label">ÏàòÏúÑ</div>
          <div class="metric-value">
            <span id="waterValue">50.0</span>
            <span class="metric-unit">%</span>
          </div>
          <div class="metric-status normal" id="waterStatus">Ï†ïÏÉÅ</div>
        </div>
      </div>

      <!-- Charts -->
      <div class="charts-container">
        <h2 style="text-align: center; margin-bottom: 30px; color: #333">
          Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÏù¥
        </h2>
        <div class="charts-grid">
          <div class="chart-container">
            <div class="chart-title">Ïò®ÎèÑ</div>
            <canvas id="tempChart"></canvas>
          </div>
          <div class="chart-container">
            <div class="chart-title">ÏäµÎèÑ</div>
            <canvas id="humidityChart"></canvas>
          </div>
          <div class="chart-container">
            <div class="chart-title">ÏÜåÎ¶¨</div>
            <canvas id="soundChart"></canvas>
          </div>
          <div class="chart-container">
            <div class="chart-title">ÏàòÏúÑ</div>
            <canvas id="waterChart"></canvas>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Global variables
      let isCollecting = false;
      let interval = 1000;
      let dataInterval;
      let currentData = {
        temperature: 25.0,
        humidity: 60.0,
        sound: 50.0,
        waterLevel: 50.0,
      };

      // Chart configurations
      const chartConfig = {
        type: "line",
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false,
            },
          },
          scales: {
            x: {
              display: true,
              grid: {
                color: "rgba(0,0,0,0.1)",
              },
            },
            y: {
              display: true,
              grid: {
                color: "rgba(0,0,0,0.1)",
              },
            },
          },
          elements: {
            point: {
              radius: 3,
              hoverRadius: 6,
            },
            line: {
              borderWidth: 2,
            },
          },
        },
      };

      // Initialize charts
      const tempCtx = document.getElementById("tempChart").getContext("2d");
      const humidityCtx = document
        .getElementById("humidityChart")
        .getContext("2d");
      const soundCtx = document.getElementById("soundChart").getContext("2d");
      const waterCtx = document.getElementById("waterChart").getContext("2d");

      const tempChart = new Chart(tempCtx, {
        ...chartConfig,
        options: {
          ...chartConfig.options,
          scales: {
            ...chartConfig.options.scales,
            y: {
              ...chartConfig.options.scales.y,
              min: 0,
              max: 40,
            },
          },
        },
        data: {
          labels: [],
          datasets: [
            {
              label: "Ïò®ÎèÑ",
              data: [],
              borderColor: "#f44336",
              backgroundColor: "rgba(244, 67, 54, 0.1)",
              fill: true,
            },
            {
              label: "ÏúÑÌóò Ïò®ÎèÑ: 30¬∞C",
              data: [],
              borderColor: "#424242",
              backgroundColor: "transparent",
              borderWidth: 2,
              borderDash: [5, 5],
              pointRadius: 0,
              pointHoverRadius: 0,
              fill: false,
            },
          ],
        },
      });

      const humidityChart = new Chart(humidityCtx, {
        ...chartConfig,
        options: {
          ...chartConfig.options,
          scales: {
            ...chartConfig.options.scales,
            y: {
              ...chartConfig.options.scales.y,
              min: 30,
              max: 80,
            },
          },
        },
        data: {
          labels: [],
          datasets: [
            {
              data: [],
              borderColor: "#ff9800",
              backgroundColor: "rgba(255, 152, 0, 0.1)",
              fill: true,
            },
          ],
        },
      });

      const soundChart = new Chart(soundCtx, {
        ...chartConfig,
        data: {
          labels: [],
          datasets: [
            {
              data: [],
              borderColor: "#4caf50",
              backgroundColor: "rgba(76, 175, 80, 0.1)",
              fill: true,
            },
          ],
        },
      });

      const waterChart = new Chart(waterCtx, {
        ...chartConfig,
        options: {
          ...chartConfig.options,
          scales: {
            ...chartConfig.options.scales,
            y: {
              ...chartConfig.options.scales.y,
              min: 0,
              max: 100,
            },
          },
        },
        data: {
          labels: [],
          datasets: [
            {
              label: "ÏàòÏúÑ",
              data: [],
              borderColor: "#1976d2",
              backgroundColor: "rgba(25, 118, 210, 0.1)",
              fill: true,
            },
            {
              label: "ÏúÑÌóò ÏàòÏúÑ: 80%",
              data: [],
              borderColor: "#424242",
              backgroundColor: "transparent",
              borderWidth: 2,
              borderDash: [5, 5],
              pointRadius: 0,
              pointHoverRadius: 0,
              fill: false,
            },
          ],
        },
      });

      // Generate data - real from Pico for temp/humidity, simulated for sound/water
      function generateData() {
        // Temperature and Humidity: Get from Pico (will be updated by fetchPicoData)
        // Sound: occasional spikes (10% chance) - keep as is
        if (Math.random() < 0.1) {
          const soundChange = (Math.random() - 0.5) * 30;
          currentData.sound += soundChange;
        } else {
          const soundChange = (Math.random() - 0.5) * 4;
          currentData.sound += soundChange;
        }
        currentData.sound = Math.max(25, Math.min(85, currentData.sound));

        // Water level: starting at 50, very gradually increasing by 0.02
        currentData.waterLevel += 0.02;
        currentData.waterLevel = Math.max(
          0,
          Math.min(100, currentData.waterLevel)
        );

        return {
          temperature: Math.round(currentData.temperature * 10) / 10,
          humidity: Math.round(currentData.humidity * 10) / 10,
          sound: Math.round(currentData.sound * 10) / 10,
          waterLevel: Math.round(currentData.waterLevel * 10) / 10,
        };
      }

      // Fetch data from Raspberry Pi Pico
      async function fetchPicoData() {
        console.log("Attempting to fetch data from Pico...");
        try {
          // Try to fetch from Pico (adjust URL/port as needed)
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 2000);

          const response = await fetch("http://192.168.0.14:8080/sensors", {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
            },
            signal: controller.signal,
          });

          clearTimeout(timeoutId);

          console.log("Response status:", response.status);
          console.log("Response ok:", response.ok);

          if (response.ok) {
            const picoData = await response.json();
            console.log("Raw Pico data:", picoData);

            // Update temperature and humidity from Pico
            if (picoData.temperature !== undefined) {
              currentData.temperature = parseFloat(picoData.temperature);
              console.log("Updated temperature:", currentData.temperature);
            }
            if (picoData.humidity !== undefined) {
              currentData.humidity = parseFloat(picoData.humidity);
              console.log("Updated humidity:", currentData.humidity);
            }
            console.log("Pico data received and processed:", picoData);

            // Update Pico connection status
            updatePicoStatus(true);
          } else {
            console.log("Response not ok, status:", response.status);
            throw new Error(`HTTP ${response.status}`);
          }
        } catch (error) {
          // If Pico is not connected, use simulated data
          console.log(
            "Pico not connected, using simulated data:",
            error.message
          );
          console.log("Full error:", error);

          // Temperature: oscillate between 24.8~25.1 randomly
          currentData.temperature = 24.8 + Math.random() * 0.3;
          // Humidity: oscillate between 60.2~61 randomly
          currentData.humidity = 60.2 + Math.random() * 0.8;

          // Update Pico connection status
          updatePicoStatus(false);
        }
      }

      // Update Pico connection status display
      function updatePicoStatus(connected) {
        const picoStatus = document.getElementById("picoStatus");
        if (connected) {
          picoStatus.innerHTML =
            '<div class="status-indicator active"></div>ÌîºÏΩî: Ïó∞Í≤∞Îê®';
          picoStatus.className = "status active small";
        } else {
          picoStatus.innerHTML =
            '<div class="status-indicator paused"></div>ÌîºÏΩî: Ïó∞Í≤∞ ÏïàÎê®';
          picoStatus.className = "status paused small";
        }
      }

      // Update metrics display
      function updateMetrics(data) {
        document.getElementById("tempValue").textContent = data.temperature;
        document.getElementById("humidityValue").textContent = data.humidity;
        document.getElementById("soundValue").textContent = data.sound;
        document.getElementById("waterValue").textContent = data.waterLevel;

        // Update status indicators
        updateStatusIndicators(data);
      }

      // Update status indicators based on danger thresholds
      function updateStatusIndicators(data) {
        // Temperature status
        const tempStatus = document.getElementById("tempStatus");
        if (data.temperature > 30) {
          tempStatus.textContent = "ÏúÑÌóò";
          tempStatus.className = "metric-status danger";
        } else {
          tempStatus.textContent = "Ï†ïÏÉÅ";
          tempStatus.className = "metric-status normal";
        }

        // Humidity status (always normal for now)
        const humidityStatus = document.getElementById("humidityStatus");
        humidityStatus.textContent = "Ï†ïÏÉÅ";
        humidityStatus.className = "metric-status normal";

        // Sound status (always normal for now)
        const soundStatus = document.getElementById("soundStatus");
        soundStatus.textContent = "Ï†ïÏÉÅ";
        soundStatus.className = "metric-status normal";

        // Water level status
        const waterStatus = document.getElementById("waterStatus");
        if (data.waterLevel > 80) {
          waterStatus.textContent = "ÏúÑÌóò";
          waterStatus.className = "metric-status danger";
        } else {
          waterStatus.textContent = "Ï†ïÏÉÅ";
          waterStatus.className = "metric-status normal";
        }
      }

      // Update charts
      function updateCharts(data) {
        const now = new Date().toLocaleTimeString();

        // Update temperature chart
        tempChart.data.labels.push(now);
        tempChart.data.datasets[0].data.push(data.temperature);
        tempChart.data.datasets[1].data.push(30); // Danger line at 30¬∞C
        if (tempChart.data.labels.length > 20) {
          tempChart.data.labels.shift();
          tempChart.data.datasets[0].data.shift();
          tempChart.data.datasets[1].data.shift();
        }
        tempChart.update("none");

        // Update humidity chart
        humidityChart.data.labels.push(now);
        humidityChart.data.datasets[0].data.push(data.humidity);
        if (humidityChart.data.labels.length > 20) {
          humidityChart.data.labels.shift();
          humidityChart.data.datasets[0].data.shift();
        }
        humidityChart.update("none");

        // Update sound chart
        soundChart.data.labels.push(now);
        soundChart.data.datasets[0].data.push(data.sound);
        if (soundChart.data.labels.length > 20) {
          soundChart.data.labels.shift();
          soundChart.data.datasets[0].data.shift();
        }
        soundChart.update("none");

        // Update water level chart
        waterChart.data.labels.push(now);
        waterChart.data.datasets[0].data.push(data.waterLevel);
        waterChart.data.datasets[1].data.push(80); // Danger line at 80%
        if (waterChart.data.labels.length > 20) {
          waterChart.data.labels.shift();
          waterChart.data.datasets[0].data.shift();
          waterChart.data.datasets[1].data.shift();
        }
        waterChart.update("none");
      }

      // Start/stop data collection
      function toggleCollection() {
        console.log("Button clicked! Current state:", isCollecting);
        if (isCollecting) {
          clearInterval(dataInterval);
          isCollecting = false;
          document.getElementById("startBtn").textContent = "Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë";
          document.getElementById("status").innerHTML =
            '<div class="status-indicator paused"></div>ÏÉÅÌÉú: Î™®ÎãàÌÑ∞ÎßÅ Ï§ë';
          document.getElementById("status").className = "status paused";
          console.log("Data collection stopped");
        } else {
          console.log("Starting data collection with interval:", interval);
          dataInterval = setInterval(async () => {
            // Fetch real data from Pico first
            await fetchPicoData();
            // Then generate complete dataset
            const newData = generateData();
            console.log("Generated data:", newData);
            updateMetrics(newData);
            updateCharts(newData);
          }, interval);
          isCollecting = true;
          document.getElementById("startBtn").textContent = "Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ";
          document.getElementById("status").innerHTML =
            '<div class="status-indicator active"></div>ÏÉÅÌÉú: Î™®ÎãàÌÑ∞ÎßÅ Ï§ë üü¢';
          document.getElementById("status").className = "status active";
          console.log("Data collection started");
        }
      }

      // Test Pico connection on page load
      async function testPicoConnection() {
        console.log("Testing Pico connection on page load...");
        try {
          const response = await fetch("http://192.168.0.14:8080/sensors");
          if (response.ok) {
            const data = await response.json();
            console.log("‚úÖ Pico connection test successful:", data);
            updatePicoStatus(true);
          } else {
            console.log(
              "‚ùå Pico connection test failed - response not ok:",
              response.status
            );
            updatePicoStatus(false);
          }
        } catch (error) {
          console.log("‚ùå Pico connection test failed:", error.message);
          updatePicoStatus(false);
        }
      }

      // Event listeners
      document.addEventListener("DOMContentLoaded", function () {
        console.log("DOM loaded, attaching event listeners");

        // Test Pico connection immediately
        testPicoConnection();

        const startBtn = document.getElementById("startBtn");
        if (startBtn) {
          console.log("Start button found, adding event listener");
          startBtn.addEventListener("click", toggleCollection);
        } else {
          console.error("Start button not found!");
        }

        const intervalSlider = document.getElementById("interval");
        if (intervalSlider) {
          console.log("Interval slider found, adding event listener");
          intervalSlider.addEventListener("input", function () {
            interval = this.value * 1000;
            document.getElementById("intervalValue").textContent =
              this.value + "Ï¥à";

            // Restart collection with new interval if currently collecting
            if (isCollecting) {
              clearInterval(dataInterval);
              dataInterval = setInterval(async () => {
                // Fetch real data from Pico first
                await fetchPicoData();
                // Then generate complete dataset
                const newData = generateData();
                updateMetrics(newData);
                updateCharts(newData);
              }, interval);
            }
          });
        } else {
          console.error("Interval slider not found!");
        }
      });

      // Initialize with current data
      updateMetrics(currentData);
    </script>
  </body>
</html>
